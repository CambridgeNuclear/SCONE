module geomGraph_class

  use numPrecision
  use genericProcedures, only : fatalError, numToChar, isIn, quickSort
  use dictionary_class,  only : dictionary
  use intMap_class,      only : intMap
  use uniFills_class,    only : uniFills

  implicit none
  private

  !!
  !! Information about a unique cell fill
  !!
  !! Public:
  !!   idx -> matIdx or -uniIdx of the filling of local cell (-ve entry indicates universe)
  !!   id  -> Unique ID if is material fill or uniRootID otherwise
  !!
  !! uniRootId is the location of the data for the given universe in array
  !!
  type, private :: location
    integer(shortInt) :: idx = 0
    integer(shortInt) :: id  = 0
  end type location

  !!
  !! Runtime representation of geometry nesting structure
  !!
  !! Is a directed acyclic graphs represented by 1D array. Each entry contains
  !! two numbers: idx which determines content (matIdx or -uniIdx); id which is
  !! a uniRootID (universe fill) or uniqueID (material fill).
  !!
  !! UniRootID is the location of the beginning of data for a given universe. Fill for diffrent
  !! local cells has the location: uniRootID + localID - 1.
  !!
  !! Note that there is no checking for the validity of localIDs! If a number outside
  !! a valid localIDs for the universe is given, content will be read form diffrent universe!
  !!
  !! Unique IDs are generated by enumeration of the graph sinks (local cells with material fill).
  !!
  !! Sample Input Dictionary:
  !!   graph1 {type shrunk;}
  !!   graph2 {type extended;}
  !!
  !!
  !! Two types are available:
  !!   'shrunk'   -> Each local (material) cell has the same uniqueID in all universe instances
  !!   'extended' -> Every local (material) cell has its own uniqueID in all universe instances
  !!
  !! Public Members:
  !!   array       -> Array with graph data
  !!   uniqueCells -> Number of uniqueCells in the structure
  !!   usedMats    -> Sorted list of matIdxs which are used in the geometry
  !!   isExtended  -> Logical stating whether or not the graph is extended
  !!
  !! Interface:
  !!   init          -> Build fron uniFills and dictionary definition
  !!   getFill       -> Get filling invormation at location given by uniRootIr & localID
  !!   getMatFromUID -> Get material ID given a cell unique ID
  !!   kill          -> Return to uninitialised state
  !!
  type, public :: geomGraph
    type(location), dimension(:), allocatable    :: array
    integer(shortInt)                            :: uniqueCells = 0
    integer(shortInt), dimension(:), allocatable :: usedMats
    integer(shortInt), dimension(:), allocatable :: matsByCell
    logical(defBool)                             :: isExtended = .FALSE.

  contains
    procedure :: init
    procedure :: getFill
    procedure :: getMatFromUID
    procedure :: kill

    ! Private procedures
    procedure, private :: buildShrunk
    procedure, private :: buildExtended
    procedure, private :: setUniqueIDs
    procedure, private :: buildMatArrayByCell
  end type geomGraph

contains

  !!
  !! Initialise graph representation of the geometry structure
  !!
  !! Args:
  !!   fills [in] -> Universe fill information
  !!   dict [in]  -> Dictionary with settings
  !!
  !! Errors:
  !!   fatalError if type (unique generation strategy) is unknown
  !!
  !! Assumes that `fills` is valid:
  !!   * No cycles
  !!   * No invalid uni indexes in the structure
  !!
  subroutine init(self, fills, dict)
    class(geomGraph), intent(inout) :: self
    type(uniFills), intent(in)      :: fills
    class(dictionary), intent(in)   :: dict
    character(nameLen)              :: type
    character(100), parameter :: Here = 'init (geomGraph_class.f90)'

    ! Select specific build procedure
    call dict % get(type, 'type')

    select case(type)
      case ('shrunk')
        call self % buildShrunk(fills)

      case ('extended')
        call self % buildExtended(fills)

      case default
        print *, "AVAILABLE GEOMETRY GRAPH TYPES:"
        print *, 'shrunk'
        print *, 'extended'
        call fatalError(Here, 'Unknown geometry graph type (unique cell generation &
                              &strategy): '//trim(type))
    end select

  end subroutine init

  !!
  !! Return fill information for a local cell in a universe
  !!
  !! Meaning of output variables depend on the sign of `idx`.
  !! If it is -ve fill is a nested universe with uniIdx = -idx and uniRootId = id
  !! If it is +ve fill is material cell with matIdx = idx and uniqueID = id
  !!
  !! Args:
  !!   idx [out] -> matIdx or -uniIdx of the content
  !!   id [out]  -> UniqueID or uniRootID
  !!   uniRootID [in] -> Location in array of the universe
  !!   localID [in] -> ID of the local cell in the univers
  !!
  !! Errors:
  !!   If localID is too large or too smal, content from diffrent universe will be read
  !!   For invalid uniRootID any content may be returned
  !!
  elemental subroutine getFill(self, idx, id, uniRootID, localID)
    class(geomGraph), intent(in) :: self
    integer(shortInt), intent(out) :: idx
    integer(shortInt), intent(out) :: id
    integer(shortInt), intent(in)  :: uniRootId
    integer(shortInt), intent(in)  :: localID

    ! Set values
    idx = self % array(uniRootId + localID -1) % idx
    id = self % array(uniRootId + localID -1) % id

  end subroutine getFill
  
  !!
  !! Given a valid unique ID, returns a material index.
  !! No checks, so make sure not to feed something incorrect...
  !!
  !! Args:
  !!   ID     -> uniqueID of a cell
  !!
  !! Result:
  !!   matIdx -> material index of the cell's contents
  !!
  !!
  pure function getMatFromUID(self, ID) result(matIdx)
    class(geomGraph), intent(in)   :: self
    integer(shortInt), intent(in)  :: ID
    integer(shortInt)              :: matIdx

    matIdx = self % matsByCell(ID)

  end function getMatFromUID
  
  !!
  !! Return to uninitialised state
  !!
  elemental subroutine kill(self)
    class(geomGraph), intent(inout) :: self

    if(allocated(self % array)) deallocate(self % array)
    if(allocated(self % usedMats)) deallocate(self % usedMats)
    self % uniqueCells = 0

  end subroutine kill


  !!
  !! Build a shrunk representation
  !!
  !! Shrunk representation assignes unique ID to every material local cell in each universe
  !! but does not distingus between instances of the same universe (e.g. all pins in a lattice
  !! are considered the same pin from the point of view of unique ID)
  !!
  !! Args:
  !!   fills [in] -> Universe fill information. Must be valid as defined in `init` procedure.
  !!
  subroutine buildShrunk(self, fills)
    class(geomGraph), intent(inout)              :: self
    type(uniFills), intent(in)                   :: fills
    integer(shortInt)                            :: i, N, top, loc, fill, rootID
    integer(shortInt), dimension(:), allocatable :: unused
    type(intMap)                                 :: layed
    integer(shortInt), parameter :: NOT_FOUND = -7
    character(100), parameter    :: Here = 'buildShrunk (geomGraph_class.f90)'

    ! Get unused univeres
    unused = fills % unusedUniverses()

    ! Allocate required space
    ! Is the number of local cells in all used universes
    N = 0
    do i = 1, size(fills % uni)
      if (.not.isIn(unused, fills % uni(i) % id)) then ! Is a used universe
        N = N + size(fills % uni(i) % fill)
      end if
    end do
    allocate (self % array(N))

    ! Lay out universes -> start with root
    ! layed stores layedout universes as a map of idx -> location
    top = 1
    loc = 1
    call layed % add(fills % root, top)
    call layoutUniverse(self % array, top, fills, fills % root)

    ! Layout rest of the universes
    do while (loc <= size(self % array))
      ! Read content
      fill = self % array(loc) % idx

      ! Set uniRoot ID and layout if is universe
      if (fill < 0) then
        rootID = layed % getOrDefault(abs(fill), NOT_FOUND)
        if (rootID == NOT_FOUND) then ! Layout the universe
          rootID = top
          call layed % add(abs(fill), top)
          call layoutUniverse(self % array, top, fills, abs(fill))

        end if
        ! Store uniRootID
        self % array(loc) % id = rootID
      end if

      ! Increment location
      loc = loc + 1
    end do

    ! Check that top was reached
    if (top /= N + 1) then
      call fatalError(Here, 'Did not reach the end of the location array. Top is: '//&
                             numToChar(top)//' but should be: '//numToChar(N+1))
    end if

    ! Set unique IDs -> Enumerate sinks
    call self % setUniqueIDs()

    call self % buildMatArrayByCell()

  end subroutine buildShrunk

  !!
  !! Build a extended representation
  !!
  !! Extended repreentation changes the directed acyclic graph into a tree. Thus, local material
  !! cells in each instance of a universe have diffrent uniqueID assigned.
  !!
  !! Args:
  !!   fills [in] -> Universe fill information. Must be valid as defined in `init` procedure.
  !!
  subroutine buildExtended(self, fills)
    class(geomGraph), intent(inout)  :: self
    type(uniFills), intent(in)       :: fills
    type(intMap)                     :: count
    integer(shortInt)                :: i, N, top, loc, fill, rootID
    character(100), parameter :: Here = 'buildExtended (geomGraph_class.f90)'

    ! Calculate required space
    ! Loop over all universes and calculate space required for all their instances
    call fills % countInstances(count)
    N = 0
    do i = 1, size(fills % uni)
      N = N + size(fills % uni(i) % fill) * count % get(i)
    end do

    ! Allocate required space
    allocate(self % array(N))

    ! Layout universes starting with root
    top = 1
    loc = 1
    call layoutUniverse(self % array, top, fills, fills % root)

    ! Layout rest of universes by going down the tree
    do while (loc <= size(self % array))
      ! Read content
      fill = self % array(loc) % idx

      ! Set uniRoot ID and layout if is universe
      if (fill < 0) then
        rootID = top
        call layoutUniverse(self % array, top, fills, abs(fill))

        ! Store uniRootID
        self % array(loc) % id = rootID

      end if

      ! Increment location
      loc = loc + 1
    end do

    ! Check that top was reached
    if (top /= N + 1) then
      call fatalError(Here, 'Did not reach the end of the location array. Top is: '//&
                             numToChar(top)//' but should be: '//numToChar(N+1))
    end if

    ! Set unique IDs -> Enumerate sinks
    call self % setUniqueIDs()

    self % isExtended = .TRUE.

    call self % buildMatArrayByCell()

  end subroutine buildExtended

  !!
  !! Loop through `array` to enumerate sinks of the graph (setting unique ID)
  !!
  !! Also set:
  !!   * Number of unique IDs
  !!   * List of matIdx used in the geometry
  !!
  !! Args:
  !!   None
  !!
  !! Errors:
  !!   Assumes `array` is allocated. Will likley segment if it isn't.
  !!
  subroutine setUniqueIDs(self)
    class(geomGraph), intent(inout) :: self
    integer(shortInt)               :: i, cells, fill, pos
    type(intMap)                    :: matSet

    ! Loop over array
    cells = 0
    do i = 1, size(self % array)
      fill = self % array(i) % idx

      if (fill > 0) then ! It is material filling
        cells = cells + 1
        self % array(i) % id = cells
        call matSet % add(fill, 1)

      end if
    end do

    ! Set number of unique cells
    self % uniqueCells = cells

    ! Set used materials
    allocate (self % usedMats( matSet % length()))

    pos = 1
    i = matSet % begin()
    do while (i /= matSet % end())
      self % usedMats(pos) = matSet % atKey(i)
      pos = pos + 1
      i = matSet % next(i)

    end do

    ! Sort used materials
    call quickSort(self % usedMats)

  end subroutine setUniqueIDs

  !!
  !! Builds an array of material indices corresponding to cell uniqueIDs.
  !! This allows for more quickly finding matIdxs given a unique ID.
  !!
  subroutine buildMatArrayByCell(self)
    class(geomGraph), intent(inout) :: self
    integer(shortInt)               :: i, cells, fill

    allocate(self % matsByCell(self % uniqueCells))
    
    cells = 0
    do i = 1, size(self % array)
      fill = self % array(i) % idx
      if (fill > 0) then ! It is material filling
        cells = cells + 1
        self % matsByCell(cells) = fill
      end if
    end do

  end subroutine buildMatArrayByCell

  !!
  !! Put universe data on the array
  !!
  !! Used by diffrent build procedures
  !!
  !! Does not set uniRootID or uniqueID !
  !!
  !! Args:
  !!   array [inout]   -> Array of locations for universe data
  !!   freeLoc [inout] -> Index of the free first free location on the array. On exit set to the
  !!     new first free location.
  !!   fills [in]      -> Universe fill information
  !!   idx [in]     -> Index of the univese to lay out
  !!
  !! Errors:
  !!   fatalError if there is not enough data in the array
  !!
  subroutine layoutUniverse(array, freeLoc, fills, idx)
    type(location), dimension(:), intent(inout) :: array
    integer(shortInt), intent(inout)            :: freeLoc
    type(uniFills), intent(in)                  :: fills
    integer(shortInt), intent(in)               :: idx
    integer(shortInt)                           :: N
    character(100), parameter :: Here = 'layoutUniverse (geomGraph_class.f90)'

    ! Check universe idx
    if ( idx < 1 .or. idx > size(fills % uni)) then
      call fatalError(Here, 'Universe index: '//numToChar(idx)//' is invalid. Must be between &
                            &1 and '//numToChar(size(fills % uni)) )
    end if

    ! Check available space
    N = size(fills % uni(idx) % fill)
    if ( freeLoc + N-1 > size(array)) then
      call fatalError(Here, 'Overflow of the location array when laying out universe &
                           &(idx): '//numToChar(idx))
    end if

    ! Layout data
    array(freeLoc: freeLoc + N -1) % idx = fills % uni(idx) % fill
    freeLoc = freeLoc + N

  end subroutine layoutUniverse


end module geomGraph_class
