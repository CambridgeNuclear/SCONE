//
// Intended as a sample/tutorial input file for calculations using IMC physics
//   package, to detail settings that differ to other calculation types
//
// Note that a lot of the input files in this branch require lightSpeed and radiationConstant both
//   to be changed to ONE in universalVariables before compiling

type IMCPhysicsPackage;

pop            1000;
  // Maximum total number of particles to be emitted during each time step from all material.
  //   This number is split between material regions based on the energy they are emitting and is
  //   reduced if limit is going to be reached.

limit          10000;
  // Sets the maximum size of particle dungeons. Runtime is very dependent on this value so should
  //   not be set arbitrarily large.

steps          50;
  // The number of time steps to be used in the calculation

timeStepSize   0.1;
  // The time step size for the calculation in seconds

printUpdates   1;
  // The number maximum number of material updates to print to screen. If 0, no updates will be
  //   printed.

collisionOperator {
                    photonMG {type IMCMGstd;}
                  }

transportOperator {
                    type transportOperatorTimeHT; cutoff 0.7;
                  }

// No tallies are required for calculation, but empty dictionary must be given
tally  {
	   }


// Geometry is as in all other calculation types.
// Here a simple infinite region is given (a perfectly reflected 1x1x1 cube)

geometry { 
    type geometryStd;
    boundary (1 1 1 1 1 1);
    graph {type shrunk;}

    surfaces {
      squareBound { id 1; type box; origin ( 0.0  0.0  0.0); halfwidth ( 0.5 0.5 0.5); }  
             }

    cells {
          }

    universes {
      root { id 1; type rootUniverse; border 1; fill mat; }
              }
}

nuclearData {

  handles { 
     mg       { type baseMgIMCDatabase; }
  }
  
  // Dictionary containing all materials used in geometry
  // If desired to have spatial temperature variation, split geometry (above) into desired cells
  //   and set each cell fill as a DIFFERENT material (e.g. mat1, mat2, mat3, ...) then define
  //   all materials here. Even if each each mat input is identical, a unique material object
  //   will be created allowing for a unique temperature evolution. The same xsFile may be used
  //   for different materials if desired.

  materials { 

    // Example: mat
    mat {

      temp       1;
        // Initial temperature of material [keV].

      composition {}
        // Empty dictionary required for composition.

      xsFile ./imcSampleMat;
        // Location of material data file containing material properties.

      volume     1;
        // Total volume that this material occupies [cm3], for now need to calculate by hand
        //   and enter here. May be room to make this automatic in the future.

    }

    // Example 2: mat2
    //mat2 { temp 1; composition {} xsFile ./imcSampleMat2; volume 1 }

} 
  
}
  
  
  
